const byte adcPin = 0;  // A0

const int BITS = 7;
const int MAX_RESULTS = 1 << BITS;

typedef int16_t VALTYPE;
#define MVTYPE 32767

volatile VALTYPE results [MAX_RESULTS];
volatile VALTYPE ims [MAX_RESULTS];
volatile int resultNumber;

inline void FFT(short int dir, long m, VALTYPE *x, VALTYPE *y)
{
    long n, i, i1, j, k, i2, l, l1, l2;
    VALTYPE c1, c2, tx, ty, t1, t2, u1, u2, z;

    /* Calculate the number of points */
    n = 1;
    for (i = 0; i < m; i++)
        n *= 2;

    /* Do the bit reversal */
    i2 = n >> 1;
    j = 0;
    for (i = 0; i < n - 1; i++)
    {
        if (i < j)
        {
            tx = x[i];
            ty = y[i];
            x[i] = x[j];
            y[i] = y[j];
            x[j] = tx;
            y[j] = ty;
        }
        k = i2;
        while (k <= j)
        {
            j -= k;
            k >>= 1;
        }
        j += k;
    }

    /* Compute the FFT */
    c1 = -1.0;
    c2 = 0.0;
    l2 = 1;
    for (l = 0; l < m; l++)
    {
        l1 = l2;
        l2 <<= 1;
        u1 = 1.0;
        u2 = 0.0;
        for (j = 0; j < l1; j++)
        {
            for (i = j; i < n; i += l2)
            {
                i1 = i + l1;
                t1 = u1 * x[i1] - u2 * y[i1];
                t2 = u1 * y[i1] + u2 * x[i1];
                x[i1] = x[i] - t1;
                y[i1] = y[i] - t2;
                x[i] += t1;
                y[i] += t2;
            }
            z = u1 * c1 - u2 * c2;
            u2 = u1 * c2 + u2 * c1;
            u1 = z;
        }
        c2 = sqrt((1.0 - c1) / 2.0);
        if (dir == 1)
            c2 = -c2;
        c1 = sqrt((1.0 + c1) / 2.0);
    }

    /* Scaling for forward transform */
    if (dir == 1)
    {
        for (i = 0; i < n; i++)
        {
            x[i] /= n;
            y[i] /= n;
        }
    }
}

void setup ()
  {
  Serial.begin (230400);
  Serial.println ();

  // reset Timer 1
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  TCCR1B = bit (CS11) | bit (WGM12);  // CTC, prescaler of 8
  TIMSK1 = bit (OCIE1B);
  OCR1A = 39;    
  OCR1B = 39;   // 20 uS - sampling frequency 50 kHz

  ADCSRA =  bit (ADEN) | bit (ADIE) | bit (ADIF);   // turn ADC on, want interrupt on completion
  ADCSRA |= bit (ADPS2);  // Prescaler of 16
//  ADCSRA |= (1 << ADPS1) | (1 << ADPS0);    // 8 prescaler for 153.8 KHz
  ADMUX = bit (REFS0) | (adcPin & 7);
  ADCSRB = bit (ADTS0) | bit (ADTS2);  // Timer/Counter1 Compare Match B
  ADCSRA |= bit (ADATE);   // turn on automatic triggering

}

// ADC complete ISR
ISR (ADC_vect)
{
    results[resultNumber++] = ADC;
    ims[resultNumber] = 0;
    if(resultNumber == MAX_RESULTS)
    {
      ADCSRA = 0;  // turn off ADC
    }
} 

EMPTY_INTERRUPT (TIMER1_COMPB_vect);

const float hanning[128] PROGMEM = {0,0.0006022718974137975,0.0024076366639015356,0.005411745017609493,0.009607359798384785,0.014984373402728013,0.021529832133895588,0.029227967408489597,0.03806023374435663,0.04800535343827833,0.059039367825822475,0.07113569499986394,0.08426519384872738,0.09839623425967753,0.1134947733186315,0.1295244373225204,0.1464466094067262,0.16422052257649078,0.18280335791817726,0.20215034775378327,0.22221488349019886,0.24294862790338917,0.2643016315870011,0.2862224532848589,0.3086582838174551,0.33155507330389,0.35485766137276886,0.378509910048368,0.40245483899193585,0.42663476277231915,0.4509914298352196,0.47546616283629095,0.49999999999999994,0.524533837163709,0.5490085701647803,0.5733652372276808,0.5975451610080641,0.6214900899516319,0.645142338627231,0.66844492669611,0.6913417161825448,0.7137775467151409,0.7356983684129988,0.7570513720966108,0.777785116509801,0.7978496522462166,0.8171966420818226,0.8357794774235092,0.8535533905932737,0.8704755626774794,0.8865052266813684,0.9016037657403224,0.9157348061512727,0.928864305000136,0.9409606321741775,0.9519946465617217,0.9619397662556434,0.9707720325915103,0.9784701678661044,0.985015626597272,0.9903926402016152,0.9945882549823906,0.9975923633360984,0.9993977281025862,1,0.9993977281025862,0.9975923633360985,0.9945882549823906,0.9903926402016152,0.985015626597272,0.9784701678661045,0.9707720325915103,0.9619397662556435,0.9519946465617217,0.9409606321741775,0.9288643050001361,0.9157348061512727,0.9016037657403224,0.8865052266813686,0.8704755626774796,0.8535533905932738,0.8357794774235093,0.817196642081823,0.7978496522462166,0.7777851165098011,0.7570513720966109,0.735698368412999,0.7137775467151413,0.6913417161825451,0.66844492669611,0.6451423386272312,0.621490089951632,0.5975451610080643,0.5733652372276812,0.5490085701647802,0.524533837163709,0.5000000000000001,0.4754661628362912,0.45099142983521995,0.42663476277231904,0.40245483899193585,0.3785099100483681,0.354857661372769,0.3315550733038902,0.30865828381745497,0.28622245328485896,0.2643016315870012,0.24294862790338922,0.22221488349019908,0.2021503477537836,0.1828033579181772,0.16422052257649083,0.14644660940672632,0.12952443732252056,0.11349477331863173,0.09839623425967747,0.08426519384872738,0.071135694999864,0.059039367825822586,0.04800535343827844,0.03806023374435674,0.029227967408489597,0.021529832133895588,0.014984373402728013,0.00960735979838484,0.005411745017609548,0.0024076366639015356,0.0006022718974137975};

void loop () {

  while (resultNumber < MAX_RESULTS)
    { }
  VALTYPE mv = 0;
  /*for(int i=0;i<MAX_RESULTS;++i) {
    if (results[i] > mv) mv = results[i];
  }
  mv = MVTYPE/mv;*/
  mv = 400;
  
  for(int i=0;i<MAX_RESULTS;++i) {
    results[i] *= mv;// * pgm_read_float(&hanning[i]);
    // Serial.println(results[i]);
  }
  FFT(1, BITS, results, ims);
  
  Serial.println("REZ");
  Serial.println(mv);

  for(int i=0;i<MAX_RESULTS/2;++i) {
    results[i] = sqrt(results[i]*results[i]+ims[i]*ims[i]);
  }
  for(int i=0;i<MAX_RESULTS/2;++i) {
    Serial.println(results[i]);
  }

  resultNumber = 0;
  ADCSRA =  bit (ADEN) | bit (ADIE) | bit (ADIF)| bit (ADPS2) | bit (ADATE); 
}
